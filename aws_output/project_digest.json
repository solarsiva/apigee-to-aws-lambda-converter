{
  "policies": {
    "AssignMessage": {
      "type": "AssignMessage",
      "name": "AssignMessage",
      "path": "apiproxy/policies/AssignMessage.xml",
      "dependencies": [],
      "content": "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<AssignMessage async=\"false\" continueOnError=\"false\" enabled=\"true\" name=\"AssignMessage-1\">\n    <DisplayName>Assign Message 1</DisplayName>\n    <Set>\n        <Payload contentType=\"application/json\">{\"message\": \"Hello from Apigee\"}</Payload>\n        <StatusCode>200</StatusCode>\n    </Set>\n    <IgnoreUnresolvedVariables>true</IgnoreUnresolvedVariables>\n</AssignMessage>"
    },
    "ServiceCallout-1": {
      "type": "ServiceCallout",
      "name": "ServiceCallout-1",
      "path": "apiproxy/policies/ServiceCallout-1.xml",
      "dependencies": [],
      "content": "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<ServiceCallout async=\"false\" continueOnError=\"false\" enabled=\"true\" name=\"ServiceCallout-1\">\n    <DisplayName>External API Call</DisplayName>\n    <Request>\n        <URL>https://api.example.com/data</URL>\n    </Request>\n    <Response>calloutResponse</Response>\n    <Timeout>30000</Timeout>\n</ServiceCallout>"
    },
    "traffic-management-policy-2": {
      "type": "AssignMessage",
      "name": "traffic-management-policy-2",
      "path": "apiproxy/policies/traffic-management-policy-2.xml",
      "dependencies": [
        "QuotaViolation",
        "RaiseFault",
        "ServiceCalloutFailed",
        "RaiseFault",
        "response.content"
      ],
      "content": "```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<!--\nThis is a complex Apigee traffic-management policy designed for production use.\nIt follows Apigee best practices and includes detailed comments.\n-->\n<VerifyAPIKey name=\"VerifyAPIKey\">\n    <!-- Verify the API key against the API products defined in the organization -->\n    <VerificationSource>request.queryparam.apikey</VerificationSource>\n</VerifyAPIKey>\n\n<Quota name=\"QuotaLimit\" type=\"calendar\">\n    <!-- Apply a quota limit to prevent abuse and manage resource consumption -->\n    <Interval>1</Interval>\n    <TimeUnit>hour</TimeUnit>\n    <Allow>1000</Allow>\n    <Identifier ref=\"request.header.client-id\"/>\n    <Distributed>true</Distributed>\n    <Synchronous>true</Synchronous>\n    <Async>true</Async>\n    <AsynchronousConfiguration>\n        <FaultRules>\n            <!-- Define fault rules for handling asynchronous quota failures -->\n            <FaultRule>\n                <Name>QuotaViolation</Name>\n                <Condition>(fault.name Matches \"QuotaViolation\")</Condition>\n                <Action>\n                    <Name>RaiseFault</Name>\n                    <Arguments>\n                        <Argument name=\"name\">QuotaViolation</Argument>\n                        <Argument name=\"failureCode\">429</Argument>\n                        <Argument name=\"errorMessage\">Quota limit exceeded</Argument>\n                    </Arguments>\n                </Action>\n            </FaultRule>\n        </FaultRules>\n    </AsynchronousConfiguration>\n</Quota>\n\n<SpikeArrest name=\"SpikeArrest\">\n    <!-- Protect against traffic spikes and DoS attacks -->\n    <Rate>10pm</Rate>\n    <UseEffectiveCount>true</UseEffectiveCount>\n    <IdentifierRef>request.header.client-id</IdentifierRef>\n</SpikeArrest>\n\n<ServiceCallout name=\"ServiceCallout\" target=\"https://example.com/service\">\n    <!-- Call an external service for additional processing or data enrichment -->\n    <Request>\n        <Set>\n            <Headers>\n                <Header name=\"Content-Type\">application/json</Header>\n            </Headers>\n        </Set>\n        <IgnoreUnresolvedVariables>true</IgnoreUnresolvedVariables>\n    </Request>\n    <Response>SuccessXML</Response>\n    <FaultRules>\n        <!-- Define fault rules for handling service callout failures -->\n        <FaultRule>\n            <Name>ServiceCalloutFailed</Name>\n            <Condition>(fault.name Matches \"ServiceCalloutFailed\")</Condition>\n            <Action>\n                <Name>RaiseFault</Name>\n                <Arguments>\n                    <Argument name=\"name\">ServiceCalloutFailed</Argument>\n                    <Argument name=\"failureCode\">500</Argument>\n                    <Argument name=\"errorMessage\">Service callout failed</Argument>\n                </Arguments>\n            </Action>\n        </FaultRule>\n    </FaultRules>\n</ServiceCallout>\n\n<XMLToJSON name=\"XMLToJSON\">\n    <!-- Convert the response from the service callout to JSON -->\n    <Source>response</Source>\n    <OutputVariable>response.json</OutputVariable>\n</XMLToJSON>\n\n<AssignMessage name=\"AssignMessage\">\n    <!-- Construct the final response to be returned to the client -->\n    <AssignTo createNew=\"true\">\n        <Name>response.content</Name>\n        <Value>{response.json}</Value>\n    </AssignTo>\n    <IgnoreUnresolvedVariables>true</IgnoreUnresolvedVariables>\n</AssignMessage>\n\n<RaiseFault name=\"RaiseFault\">\n    <!-- Raise a fault if any errors occur during policy execution -->\n    <FaultResponse>\n        <Set>\n            <Headers>\n                <Header"
    },
    "extension-policy-2": {
      "type": "Extension",
      "name": "extension-policy-2",
      "path": "apiproxy/policies/extension-policy-2.xml",
      "dependencies": [
        "xsl://transform-template.xsl"
      ],
      "content": "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<!--\n  This is a complex Apigee extension policy that focuses on data transformation, validation,\n  and integration capabilities. It complements extension-policy-1 by providing additional\n  functionality for API processing.\n-->\n<ExtensionBundle name=\"data-processing-extension\">\n    <ExtensionPolicy>\n        <!-- Data Validation Policy -->\n        <ValidationPolicy name=\"DataValidationPolicy\">\n            <DisplayName>Data Validation Policy</DisplayName>\n            <Description>Validates incoming request data against JSON Schema</Description>\n            <Properties />\n            <ValidationFlow>\n                <!-- JSON Schema Validation -->\n                <SchemaValidation>\n                    <Schema>\n                        {\n                        \"type\": \"object\",\n                        \"required\": [\"userId\", \"data\"],\n                        \"properties\": {\n                        \"userId\": {\n                        \"type\": \"string\",\n                        \"pattern\": \"^[A-Za-z0-9]{8,}$\"\n                        },\n                        \"data\": {\n                        \"type\": \"object\",\n                        \"required\": [\"type\", \"content\"],\n                        \"properties\": {\n                        \"type\": {\n                        \"type\": \"string\",\n                        \"enum\": [\"text\", \"json\", \"xml\"]\n                        },\n                        \"content\": {\n                        \"type\": \"string\"\n                        }\n                        }\n                        }\n                        }\n                        }\n                    </Schema>\n                    <ErrorHandling>\n                        <DefaultFault>\n                            <FaultResponse>\n                                <StatusCode>400</StatusCode>\n                                <ReasonPhrase>Invalid Request Data</ReasonPhrase>\n                                <FaultString>Request payload validation failed</FaultString>\n                            </FaultResponse>\n                        </DefaultFault>\n                    </ErrorHandling>\n                </SchemaValidation>\n            </ValidationFlow>\n        </ValidationPolicy>\n\n        <!-- Data Transformation Policy -->\n        <TransformationPolicy name=\"DataTransformationPolicy\">\n            <DisplayName>Data Transformation Policy</DisplayName>\n            <Description>Transforms data between different formats</Description>\n            <Properties />\n            <TransformationFlow>\n                <!-- XSLT Transformation -->\n                <XSLTransformation>\n                    <ResourceURL>xsl://transform-template.xsl</ResourceURL>\n                    <Parameters>\n                        <Parameter name=\"format\">json</Parameter>\n                        <Parameter name=\"version\">2.0</Parameter>\n                    </Parameters>\n                    <OutputVariable>transformed.content</OutputVariable>\n                </XSLTransformation>\n                <!-- JSON Transform -->\n                <JSONTransformation>\n                    <Template>\n                        {\n                        \"mappedData\": {\n                        \"id\": \"${request.body.data.id}\",\n                        \"type\": \"${request.body.data.type}\",\n                        \"processedContent\": \"${transformed.content}\",\n                        \"timestamp\": \"${system.timestamp}\"\n                        }\n                        }\n                    </Template>\n                    <OutputVariable>final.output</OutputVariable>\n                </JSONTransformation>\n            </TransformationFlow>\n        </TransformationPolicy>\n\n        <!-- Integration Policy -->\n        <IntegrationPolicy name=\"ExternalIntegrationPolicy\">\n            <DisplayName>External Integration Policy</DisplayName>\n            <Description>Handles integration with external services</Description>\n            <Properties />\n            <IntegrationFlow>\n                <!-- Circuit Breaker Configuration -->\n                <CircuitBreaker>\n                    <FailureThreshold>5</FailureThreshold>\n                    <ResetTimeout>60000</ResetTimeout>\n                    <ErrorCodes>\n                        <Code>500</Code>\n                        <Code>502</Code>\n                        <Code>503</Code>\n                    </ErrorCodes>\n                </CircuitBreaker>\n                <!-- Retry Configuration -->\n                <RetryConfiguration>\n                    <MaxRetries>3</MaxRetries>\n                    <RetryInterval>1000</RetryInterval>\n                    <BackoffMultiplier>2</BackoffMultiplier>\n                </RetryConfiguration>\n                <!-- Service Endpoints -->\n                <ServiceEndpoints>\n                    <Endpoint name=\"primary\">\n                        <URL>https://api.primary-service.com/v1</URL>\n                        <Timeout>5000</Timeout>\n                        <Authentication>\n                            <Type>oauth2</Type>\n                            <ClientId>${properties.integration.client_id}</ClientId>\n                            <ClientSecret>${properties.integration.client_secret}</ClientSecret>\n                        </Authentication>\n                    </Endpoint>\n                    <Endpoint name=\"fallback\">\n                        <URL>https://api.backup-service.com/v1</URL>\n                        <Timeout>3000</Timeout>\n                        <Authentication>\n                            <Type>apikey</Type>\n                            <KeyLocation>header</KeyLocation>\n                            <KeyName>X-API-Key</KeyName>\n                            <KeyValue>${properties.integration.api_key}</KeyValue>\n                        </Authentication>\n                    </Endpoint>\n                </ServiceEndpoints>\n            </IntegrationFlow>\n        </IntegrationPolicy>\n\n        <!-- Metrics and Analytics Policy -->\n        <MetricsPolicy name=\"MetricsCollectionPolicy\">\n            <DisplayName>Metrics Collection Policy</DisplayName>\n            <Description>Collects and processes API metrics</Description>\n            <Properties />\n            <MetricsFlow>\n                <!-- Custom Metrics -->\n                <CustomMetrics>\n                    <Metric name=\"processing_time\">\n                        <Value>#{system.timestamp - request.received.timestamp}</Value>\n                        <Type>timer</Type>\n                        <Tags>\n                            <Tag name=\"endpoint\">{proxy.pathsuffix}</Tag>\n                            <Tag name=\"method\">{request.verb}</Tag>\n                        </Tags>\n                    </Metric>\n                    <Metric name=\"payload_size\">\n                        <Value>#{request.header.content-length}</Value>\n                        <Type>gauge</Type>\n                    </Metric>\n                </CustomMetrics>\n                <!-- Analytics Configuration -->\n                <Analytics>\n                    <Enabled>true</Enabled>\n                    <SamplingRate>100</SamplingRate>\n                    <DataCapture>\n                        <Request>\n                            <Headers>true</Headers>\n                            <QueryParams>true</QueryParams>\n                            <Payload>false</Payload>\n                        </Request>\n                        <Response>\n                            <Headers>true</Headers>\n                            <Payload>false</Payload>\n                        </Response>\n                    </DataCapture>\n                </Analytics>\n            </MetricsFlow>\n        </MetricsPolicy>\n    </ExtensionPolicy>\n</ExtensionBundle>"
    },
    "JavaScript-1": {
      "type": "JavaScript",
      "name": "JavaScript-1",
      "path": "apiproxy/policies/JavaScript-1.xml",
      "dependencies": [],
      "content": "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<Javascript async=\"false\" continueOnError=\"false\" enabled=\"true\" timeLimit=\"200\" name=\"JavaScript-1\">\n    <DisplayName>JavaScript Policy 1</DisplayName>\n    <Properties/>\n    <Resource>var message = context.getVariable(\"message.content\");\ncontext.setVariable(\"processed.message\", message.toUpperCase());</Resource>\n</Javascript>"
    },
    "traffic-management-policy-1": {
      "type": "SpikeArrest",
      "name": "traffic-management-policy-1",
      "path": "apiproxy/policies/traffic-management-policy-1.xml",
      "dependencies": [],
      "content": "```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<!--\n    This is a complex Apigee traffic-management policy XML that includes realistic settings and configurations\n    that would be used in a production environment. The policy follows Apigee best practices and includes detailed\n    comments to explain each section.\n-->\n<policies>\n    <!-- Quota Policy to limit the number of requests per API key -->\n    <Quota async=\"true\" continueOnError=\"false\" enabled=\"true\" name=\"Quota\">\n        <DisplayName>Quota</DisplayName>\n        <Properties/>\n        <Allow countRef=\"apiproduct.developer.quota.count\" count=\"1000\" countName=\"RequestCount\" timeUnit=\"hour\">\n            <Identifier ref=\"request.queryparam.apikey\" />\n        </Allow>\n        <Interval ref=\"request.header.Client-ID\">hourly</Interval>\n        <TimeUnit>hour</TimeUnit>\n        <Distributed>true</Distributed>\n        <Synchronous>false</Synchronous>\n        <StartTime>2023-04-01 00:00:00</StartTime>\n        <UniformWindowSize>true</UniformWindowSize>\n        <AsynchronousConfiguration>\n            <FromSendStreamName>quota-request-stream</FromSendStreamName>\n            <UnboundedQueueSize>true</UnboundedQueueSize>\n        </AsynchronousConfiguration>\n    </Quota>\n\n    <!-- Spike Arrest Policy to protect against traffic spikes -->\n    <SpikeArrest async=\"true\" continueOnError=\"false\" enabled=\"true\" name=\"Spike-Arrest\">\n        <DisplayName>Spike Arrest</DisplayName>\n        <Properties/>\n        <Rate>10pm</Rate>\n        <UseEffectiveCount>true</UseEffectiveCount>\n        <Identifier ref=\"request.header.Client-ID\" />\n        <MessageWeight>1</MessageWeight>\n        <AsynchronousConfiguration>\n            <FromSendStreamName>spike-arrest-request-stream</FromSendStreamName>\n            <UnboundedQueueSize>true</UnboundedQueueSize>\n        </AsynchronousConfiguration>\n    </SpikeArrest>\n\n    <!-- JSON Threat Protection Policy to defend against JSON-based attacks -->\n    <JSONThreatProtection async=\"true\" continueOnError=\"false\" enabled=\"true\" name=\"JSON-Threat-Protection\">\n        <DisplayName>JSON Threat Protection</DisplayName>\n        <Properties/>\n        <Source>request</Source>\n        <JSONThreatProtectionPolicy>\n            <MaxObjectDepth>10</MaxObjectDepth>\n            <MaxArraySize>100</MaxArraySize>\n            <MaxStringSize>1024</MaxStringSize>\n            <MaxObjectSize>4096</MaxObjectSize>\n            <IgnoreRemoteSchemaConflict>false</IgnoreRemoteSchemaConflict>\n            <IgnoreRemoteSchemaResolutionErrors>false</IgnoreRemoteSchemaResolutionErrors>\n        </JSONThreatProtectionPolicy>\n        <OutputVariable>json_threat_protection_output</OutputVariable>\n        <AsynchronousConfiguration>\n            <FromSendStreamName>json-threat-protection-request-stream</FromSendStreamName>\n            <UnboundedQueueSize>true</UnboundedQueueSize>\n        </AsynchronousConfiguration>\n    </JSONThreatProtection>\n\n    <!-- XML Threat Protection Policy to defend against XML-based attacks -->\n    <XMLThreatProtection async=\"true\" continueOnError=\"false\" enabled=\"true\" name=\"XML-Threat-Protection\">\n        <DisplayName>XML Threat Protection</DisplayName>\n        <Properties/>\n        <Source>request</Source>\n        <XMLThreatProtectionPolicy>\n            <MaxAttributeCount>100</MaxAttributeCount>\n            <MaxAttributeValueLength>1024</MaxAttributeValueLength>\n            <MaxChildrenCount>1000</MaxChildrenCount>\n            <MaxElementDepth>10</MaxElementDepth>\n            <MaxElementNameLength>"
    },
    "extension-policy-1": {
      "type": "OAuth",
      "name": "extension-policy-1",
      "path": "apiproxy/policies/extension-policy-1.xml",
      "dependencies": [],
      "content": "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<!--\n  This is a complex Apigee extension policy that includes various configurations and settings that\ncould be used in a production environment.\n  It follows Apigee best practices and includes detailed comments to explain the purpose and usage of\neach element.\n-->\n<ExtensionBundle name=\"complex-extension-policy\">\n  <ExtensionPolicy>\n    <!-- This policy is responsible for handling authentication and authorization -->\n    <AuthenticationPolicy name=\"AuthenticationPolicy\">\n      <DisplayName>Authentication Policy</DisplayName>\n      <Description>Handles authentication and authorization for incoming requests.</Description>\n      <Properties />\n      <CredentialReferenceEntries>\n        <!-- Reference to an Apigee key-value map containing OAuth credentials -->\n        <CredentialReferenceEntry name=\"oauth-credentials\" source=\"request\"\n          selector=\"request.queryparam.oauth_token\" />\n      </CredentialReferenceEntries>\n      <AuthenticationFlow>\n        <!-- Validate the OAuth token against an external OAuth provider -->\n        <OAuthV2Verification>\n          <OperationResources>\n            <OperationResource operationName=\"GET\" path=\"/resource\">\n              <Methods>\n                <!-- Specify the allowed HTTP methods for this resource -->\n                <Method>GET</Method>\n              </Methods>\n            </OperationResource>\n          </OperationResources>\n          <CredentialRef>oauth-credentials</CredentialRef>\n          <AuthorizationUrl>https://example.com/oauth/authorize</AuthorizationUrl>\n          <TokenUrl>https://example.com/oauth/token</TokenUrl>\n          <ClientId>YOUR_CLIENT_ID</ClientId>\n          <ClientSecret>YOUR_CLIENT_SECRET</ClientSecret>\n          <Scopes>\n            <!-- Define the required scopes for this resource -->\n            <Scope>read</Scope>\n          </Scopes>\n        </OAuthV2Verification>\n      </AuthenticationFlow>\n    </AuthenticationPolicy>\n\n    <!-- This policy handles rate limiting for incoming requests -->\n    <RateLimitingPolicy name=\"RateLimitingPolicy\">\n      <DisplayName>Rate Limiting Policy</DisplayName>\n      <Description>Limits the number of requests per client.</Description>\n      <Properties />\n      <RateLimitingFlow>\n        <!-- Configure rate limiting based on client IP address -->\n        <IPAddressRateLimiting>\n          <DistributedRateLimiting>\n            <!-- Use a distributed rate limiting strategy -->\n            <Enabled>true</Enabled>\n            <SyncWindow>\n              <!-- Set the sync window to 1 minute -->\n              <TimeUnit>minute</TimeUnit>\n              <Value>1</Value>\n            </SyncWindow>\n          </DistributedRateLimiting>\n          <Rate>\n            <!-- Allow 100 requests per minute per client IP -->\n            <TimeUnit>minute</TimeUnit>\n            <Value>100</Value>\n          </Rate>\n          <IdentifierRef>request.remoteaddr</IdentifierRef>\n        </IPAddressRateLimiting>\n      </RateLimitingFlow>\n    </RateLimitingPolicy>\n\n    <!-- This policy handles caching of responses -->\n    <CachingPolicy name=\"CachingPolicy\">\n      <DisplayName>Caching Policy</DisplayName>\n      <Description>Caches responses to improve performance.</Description>\n      <Properties />\n      <CacheResources>\n        <!-- Define the resources to be cached -->\n        <CacheResource>\n          <Methods>\n            <!-- Cache GET requests -->\n            <Method>GET</Method>\n          </Methods>\n          <Path>/resource</Path>\n        </CacheResource>\n      </CacheResources>\n      <CacheEntrySettings>\n        <!-- Configure cache entry settings -->\n        <TimeoutInSec>300</TimeoutInSec>\n        <MaxEntries>1000</MaxEntries>\n      </CacheEntrySettings>\n    </CachingPolicy>\n\n    <!-- This policy handles logging of requests and responses -->\n    <LoggingPolicy name=\"LoggingPolicy\">\n      <DisplayName>Logging Policy</DisplayName>\n      <Description>Logs request and response details for monitoring and debugging.</Description>\n      <Properties />\n      <LoggingFlow>\n        <!-- Configure request logging -->\n        <RequestLogging>\n          <Enabled>true</Enabled>\n          <LogLevel>INFO</LogLevel>\n          <Variables>\n            <!-- Log specific request variables -->\n            <Variable>request.header.user-agent</Variable>\n            <Variable>request.queryparam.all</Variable>\n            <Variable>request.content</Variable>\n          </Variables>\n        </RequestLogging>\n        <!-- Configure response logging -->\n        <ResponseLogging>\n          <Enabled>true</Enabled>\n          <LogLevel>INFO</LogLevel>\n          <Variables>\n            <!-- Log specific response variables -->\n            <Variable>response.status.code</Variable>\n            <Variable>response.header.content-type</Variable>\n            <Variable>response.content</Variable>\n          </Variables>\n        </ResponseLogging>\n      </LoggingFlow>\n    </LoggingPolicy>\n  </ExtensionPolicy>\n</ExtensionBundle>"
    },
    "mediation-policy-2": {
      "type": "AssignMessage",
      "name": "mediation-policy-2",
      "path": "apiproxy/policies/mediation-policy-2.xml",
      "dependencies": [
        "client_id",
        "request.verb",
        "GetProductsRequest",
        "GetProductsResponse",
        "response.header.Content-Type",
        "jsc://transform.js"
      ],
      "content": "```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<!--\nThis is a complex Apigee mediation policy that follows best practices for production use.\nIt includes various policy types, such as JavaScript, Quota, Spike Arrest, and more.\n-->\n<APIProxy revision=\"1\" name=\"ComplexProxy\">\n    <Description>A complex Apigee proxy with various policies</Description>\n    <PreFlow name=\"PreFlow\">\n        <!-- Verify API key and quota -->\n        <VerifyAPIKey name=\"VerifyAPIKey\">\n            <APIKey ref=\"request.queryparam.apikey\" />\n        </VerifyAPIKey>\n        <Quota name=\"QuotaPolicy\" type=\"calendar\">\n            <Identifier ref=\"request.header.client-id\" />\n            <AllowedCounters>\n                <Counter>calls</Counter>\n            </AllowedCounters>\n            <Interval>1</Interval>\n            <TimeUnit>hour</TimeUnit>\n            <Limit>1000</Limit>\n            <CounterStrategy>FASTEST</CounterStrategy>\n            <Distributed>true</Distributed>\n            <Synchronous>true</Synchronous>\n        </Quota>\n\n        <!-- Spike Arrest to prevent API abuse -->\n        <SpikeArrest name=\"SpikeArrest\">\n            <IdentifierRef>client_id</IdentifierRef>\n            <Rate>10pm</Rate>\n            <UseEffectiveCount>true</UseEffectiveCount>\n        </SpikeArrest>\n\n        <!-- JavaScript policy for data transformation -->\n        <Javascript name=\"JSTransformation\">\n            <ResourceURL>jsc://transform.js</ResourceURL>\n            <IncludeURL>jsc://helpers.js</IncludeURL>\n        </Javascript>\n\n        <!-- XML-to-JSON policy -->\n        <XMLToJSON name=\"XMLToJSON\" />\n\n        <!-- Assign message properties -->\n        <AssignMessage name=\"AssignMessageProperties\">\n            <AssignVariable>\n                <Name>client_id</Name>\n                <Ref>request.header.client-id</Ref>\n            </AssignVariable>\n            <AssignVariable>\n                <Name>request.verb</Name>\n                <Ref>request.verb</Ref>\n            </AssignVariable>\n        </AssignMessage>\n    </PreFlow>\n\n    <Flows>\n        <Flow name=\"GetProductsFlow\">\n            <Description>Flow for GET /products endpoint</Description>\n            <Condition>(proxy.pathsuffix MatchesPath \"/products\") and (request.verb = \"GET\")</Condition>\n            <Request>\n                <Step>\n                    <Name>GetProductsRequest</Name>\n                </Step>\n            </Request>\n            <Response>\n                <Step>\n                    <Name>GetProductsResponse</Name>\n                </Step>\n            </Response>\n        </Flow>\n    </Flows>\n\n    <PostFlow name=\"PostFlow\">\n        <!-- Log response payload -->\n        <LogResponse name=\"LogResponse\">\n            <Enabled>true</Enabled>\n        </LogResponse>\n\n        <!-- JSON-to-XML policy -->\n        <JSONToXML name=\"JSONToXML\" />\n\n        <!-- Assign response headers -->\n        <AssignMessage name=\"AssignResponseHeaders\">\n            <AssignVariable>\n                <Name>response.header.Content-Type</Name>\n                <Value>application/xml</Value>\n            </AssignVariable>\n        </AssignMessage>\n    </PostFlow>\n\n    <HTTPProxyConnection>\n        <!-- Load balancing across multiple backend instances -->\n        <LoadBalancer>\n            <Server name=\"backend1\" cluster=\"production\">\n                <HTTPTargetConnection>\n                    <URL>https://backend1.example.com</URL>\n                </HTTPTargetConnection>\n            </Server>\n            <Server name=\"backend2\" cluster=\"production\">\n                <HTTPTargetConnection>\n                    <URL>https://backend2.example.com</URL>\n                </HTTPTargetConnection>\n            </Server>\n        </LoadBalancer>\n    </"
    },
    "mediation-policy-1": {
      "type": "SpikeArrest",
      "name": "mediation-policy-1",
      "path": "apiproxy/policies/mediation-policy-1.xml",
      "dependencies": [
        "OAuth-v2",
        "oauth.decoded_token",
        "OAuth-v2-Verify",
        "LogRequestPayload",
        "LogRequestHeaders",
        "LogResponsePayload",
        "LogResponseHeaders",
        "XMLToJSON",
        "TransformRequestPayload",
        "TransformResponsePayload",
        "SpikeArrest"
      ],
      "content": "```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<!-- This is a complex Apigee mediation policy that includes various configurations and settings.\n     It follows Apigee best practices and includes detailed comments explaining each step. -->\n<APIProxy name=\"ComplexMediation\" revision=\"1\">\n    <Description>Complex Apigee mediation policy</Description>\n\n    <!-- Define the proxy endpoint and routing rules -->\n    <ProxyEndpoints>\n        <ProxyEndpoint name=\"default\">\n            <HTTPProxyConnection>\n                <!-- Configure the backend target endpoint -->\n                <URL>https://api.example.com</URL>\n            </HTTPProxyConnection>\n            <RouteRule name=\"default\">\n                <TargetEndpoint>default</TargetEndpoint>\n            </RouteRule>\n        </ProxyEndpoint>\n    </ProxyEndpoints>\n\n    <!-- Define the request and response flow policies -->\n    <Flows>\n        <Flow name=\"ProtectAPIWithOAuth\">\n            <!-- Verify the OAuth token and extract claims -->\n            <Request>\n                <Step>\n                    <Name>OAuth-v2</Name>\n                    <AssignVariable>\n                        <Name>oauth.decoded_token</Name>\n                        <Ref>decoded-jwt</Ref>\n                    </AssignVariable>\n                </Step>\n                <!-- Check if the token is valid and has the required scopes -->\n                <Step>\n                    <Name>OAuth-v2-Verify</Name>\n                    <ConditionExpr>{oauth.decoded_token.scope} =~ /^(read|write)$/</ConditionExpr>\n                </Step>\n            </Request>\n            <Response/>\n        </Flow>\n\n        <Flow name=\"LogRequestAndResponse\">\n            <!-- Log the request payload and headers -->\n            <Request>\n                <Step>\n                    <Name>LogRequestPayload</Name>\n                    <Condition>request.verb == \"POST\" || request.verb == \"PUT\"</Condition>\n                </Step>\n                <Step>\n                    <Name>LogRequestHeaders</Name>\n                </Step>\n            </Request>\n            <!-- Log the response payload and headers -->\n            <Response>\n                <Step>\n                    <Name>LogResponsePayload</Name>\n                    <Condition>response.status.code >= 400</Condition>\n                </Step>\n                <Step>\n                    <Name>LogResponseHeaders</Name>\n                </Step>\n            </Response>\n        </Flow>\n\n        <Flow name=\"TransformRequest\">\n            <!-- Transform the request payload using an XSLT stylesheet -->\n            <Request>\n                <Step>\n                    <Name>XMLToJSON</Name>\n                    <Condition>request.header.Content-Type == \"application/xml\"</Condition>\n                </Step>\n                <Step>\n                    <Name>TransformRequestPayload</Name>\n                    <Condition>request.verb == \"POST\" || request.verb == \"PUT\"</Condition>\n                    <Request>TransformRequestPayload.xslt</Request>\n                </Step>\n            </Request>\n            <Response/>\n        </Flow>\n\n        <Flow name=\"TransformResponse\">\n            <!-- Transform the response payload using a JavaScript policy -->\n            <Response>\n                <Step>\n                    <Name>TransformResponsePayload</Name>\n                    <Request>TransformResponsePayload.js</Request>\n                </Step>\n            </Response>\n        </Flow>\n\n        <Flow name=\"RateLimitAPI\">\n            <!-- Apply rate limiting to the API -->\n            <Request>\n                <Step>\n                    <Name>SpikeArrest</Name>\n                    <Condition>request.queryparam.apikey != null</Condition>\n                    <SpikeArrestPolicy>\n                        <Rate>10pm</Rate>\n                        <UseEffectiveCount>true</UseEffectiveCount>\n                        <IdentifierRef>request.queryparam.apikey</IdentifierRef>\n                    </SpikeArrestPolicy>\n                </Step>\n            </Request>"
    },
    "security-policy-2": {
      "type": "Unknown",
      "name": "security-policy-2",
      "path": "apiproxy/policies/security-policy-2.xml",
      "dependencies": [
        "VerifyAPIKey",
        "VerifyAPIKey",
        "UnauthorizedRequest",
        "UnauthorizedRequest",
        "JSONThreatProtection",
        "JSONThreatProtection",
        "BadRequest",
        "BadRequest"
      ],
      "content": "```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<!--\n  This is a complex Apigee security policy that follows best practices and includes realistic settings and configurations for production use.\n-->\n<XMLPolicy xmlns=\"http://www.sap.com/apigee/xml/XMLPolicy\">\n  <XPath>\n    <!-- Apply the policy to all requests -->\n    <Path>/</Path>\n  </XPath>\n  <Resources>\n    <!-- Include the required resources for security policies -->\n    <Resource>java://apigee-utils-20180703.jar</Resource>\n    <Resource>java://apigee-xml-utils-20170110.jar</Resource>\n  </Resources>\n  <Steps>\n    <!-- Validate the API key -->\n    <Step>\n      <Name>VerifyAPIKey</Name>\n      <Condition>request.verb == \"GET\" or request.verb == \"POST\"</Condition>\n      <Request>\n        <Set>\n          <Payload>{request.content}</Payload>\n          <Verb>{request.verb}</Verb>\n        </Set>\n      </Request>\n      <Response>\n        <Step>\n          <Name>VerifyAPIKey</Name>\n          <ClassName>com.apigee.callout.security.VerifyAPIKey</ClassName>\n          <Request>\n            <Set>\n              <Headers>\n                <Header name=\"Content-Type\">application/json</Header>\n              </Headers>\n              <Payload>{request.content}</Payload>\n            </Set>\n          </Request>\n          <Response>\n            <Set>\n              <StatusCode>{response.status.code}</StatusCode>\n              <ReasonPhrase>{response.status.reason}</ReasonPhrase>\n              <Payload>{response.content}</Payload>\n            </Set>\n          </Response>\n          <Conditions>\n            <Condition>response.status.code == 401</Condition>\n          </Conditions>\n          <FaultRules>\n            <FaultRule>\n              <Name>UnauthorizedRequest</Name>\n              <Step>\n                <Name>UnauthorizedRequest</Name>\n                <ClassName>com.apigee.callout.fault.UnauthorizedRequest</ClassName>\n                <Request>\n                  <Set>\n                    <Headers>\n                      <Header name=\"Content-Type\">application/json</Header>\n                    </Headers>\n                    <Payload>{response.content}</Payload>\n                  </Set>\n                </Request>\n                <Response/>\n              </Step>\n            </FaultRule>\n          </FaultRules>\n        </Step>\n      </Response>\n    </Step>\n    <!-- Validate the JSON payload -->\n    <Step>\n      <Name>JSONThreatProtection</Name>\n      <Condition>request.verb == \"POST\"</Condition>\n      <Request>\n        <Set>\n          <Payload>{request.content}</Payload>\n          <Verb>{request.verb}</Verb>\n        </Set>\n      </Request>\n      <Response>\n        <Step>\n          <Name>JSONThreatProtection</Name>\n          <ClassName>com.apigee.callout.threat.JSONThreatProtection</ClassName>\n          <Request>\n            <Set>\n              <Headers>\n                <Header name=\"Content-Type\">application/json</Header>\n              </Headers>\n              <Payload>{request.content}</Payload>\n            </Set>\n          </Request>\n          <Response>\n            <Set>\n              <StatusCode>{response.status.code}</StatusCode>\n              <ReasonPhrase>{response.status.reason}</ReasonPhrase>\n              <Payload>{response.content}</Payload>\n            </Set>\n          </Response>\n          <Conditions>\n            <Condition>response.status.code == 400</Condition>\n          </Conditions>\n          <FaultRules>\n            <FaultRule>\n              <Name>BadRequest</Name>\n              <Step>\n                <Name>BadRequest</Name>\n                <ClassName>com.ap"
    },
    "security-policy-1": {
      "type": "Unknown",
      "name": "security-policy-1",
      "path": "apiproxy/policies/security-policy-1.xml",
      "dependencies": [],
      "content": "```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<!--\n    This is a complex Apigee security policy that follows best practices for securing APIs in production environments.\n    It includes various security measures such as OAuth 2.0 protection, IP address filtering, rate limiting, threat protection, and more.\n-->\n<policies xmlns=\"http://apigee.com/VerifyAPIKey\">\n    <policy name=\"Verify API Key\" revision=\"1\">\n        <!--\n            This policy verifies the API key passed in the request header or query parameter.\n            It ensures that only authorized clients with valid API keys can access the API.\n        -->\n        <verify-api-key>\n            <header-name>X-API-Key</header-name>\n            <query-param-name>api_key</query-param-name>\n        </verify-api-key>\n    </policy>\n\n    <policy name=\"OAuth 2.0\" revision=\"1\">\n        <!--\n            This policy enforces OAuth 2.0 protection for the API.\n            It validates the access token and ensures that the client has the necessary scopes and permissions.\n        -->\n        <oauth2>\n            <verify-api-key>\n                <header-name>Authorization</header-name>\n                <query-param-name>access_token</query-param-name>\n            </verify-api-key>\n            <scope-ref>\n                <name>read</name>\n                <name>write</name>\n            </scope-ref>\n        </oauth2>\n    </policy>\n\n    <policy name=\"IP Address Filtering\" revision=\"1\">\n        <!--\n            This policy filters incoming requests based on the client's IP address.\n            It allows or denies access based on a whitelist or blacklist of IP addresses or ranges.\n        -->\n        <ip-access>\n            <allowed-ip>192.168.1.0/24</allowed-ip>\n            <allowed-ip>10.0.0.0/8</allowed-ip>\n            <denied-ip>1.2.3.4</denied-ip>\n        </ip-access>\n    </policy>\n\n    <policy name=\"Rate Limiting\" revision=\"1\">\n        <!--\n            This policy limits the rate of incoming requests to protect against abuse and denial of service attacks.\n            It can be configured with different rate limits based on the client, API, or resource.\n        -->\n        <quota>\n            <allow>10</allow>\n            <interval>60</interval>\n            <time-unit>second</time-unit>\n            <identifier>\n                <header-name>X-Client-ID</header-name>\n            </identifier>\n        </quota>\n    </policy>\n\n    <policy name=\"Threat Protection\" revision=\"1\">\n        <!--\n            This policy provides protection against various threats such as SQL injection, cross-site scripting (XSS), and other malicious attacks.\n            It inspects and sanitizes incoming requests to prevent exploits.\n        -->\n        <threat-protection>\n            <sql-injection>\n                <enabled>true</enabled>\n            </sql-injection>\n            <xss>\n                <enabled>true</enabled>\n            </xss>\n            <malicious-ip>\n                <enabled>true</enabled>\n                <action>deny</action>\n            </malicious-ip>\n        </threat-protection>\n    </policy>\n\n    <policy name=\"Content Validation\" revision=\"1\">\n        <!--\n            This policy validates the content of incoming requests to ensure they conform to expected formats and schemas.\n            It can validate XML, JSON, or other data formats based on predefined schemas or rules.\n        -->\n        <content-validation>\n            <schema-file>schema.xsd</schema-file>\n            <validation-errors>\n                <enabled>true</enabled>\n                <action>reject</action>\n            </validation-errors>\n        </content-validation>\n    </policy>\n\n    <policy name=\"CORS\" revision=\"1\">\n        <!--\n            This policy enables Cross-Origin Resource Sharing (CORS) for the API, allowing it to be accessed from different domains.\n            It can be configured with allowed origins, methods, headers, and other"
    }
  },
  "resources": {},
  "dependencies": {
    "AssignMessage": [],
    "ServiceCallout-1": [],
    "traffic-management-policy-2": [
      "QuotaViolation",
      "RaiseFault",
      "ServiceCalloutFailed",
      "RaiseFault",
      "response.content"
    ],
    "extension-policy-2": [
      "xsl://transform-template.xsl"
    ],
    "JavaScript-1": [],
    "traffic-management-policy-1": [],
    "extension-policy-1": [],
    "mediation-policy-2": [
      "client_id",
      "request.verb",
      "GetProductsRequest",
      "GetProductsResponse",
      "response.header.Content-Type",
      "jsc://transform.js"
    ],
    "mediation-policy-1": [
      "OAuth-v2",
      "oauth.decoded_token",
      "OAuth-v2-Verify",
      "LogRequestPayload",
      "LogRequestHeaders",
      "LogResponsePayload",
      "LogResponseHeaders",
      "XMLToJSON",
      "TransformRequestPayload",
      "TransformResponsePayload",
      "SpikeArrest"
    ],
    "security-policy-2": [
      "VerifyAPIKey",
      "VerifyAPIKey",
      "UnauthorizedRequest",
      "UnauthorizedRequest",
      "JSONThreatProtection",
      "JSONThreatProtection",
      "BadRequest",
      "BadRequest"
    ],
    "security-policy-1": []
  }
}